# 密码加密技术方案

## 概述

本文档描述 Daily Report 系统中用户密码的加密存储方案，采用**每个用户独立的盐值（password_salt）**作为校验位，确保密码安全性和唯一性。

---

## 核心设计

### 1. 数据库存储结构

```prisma
model User {
  id            String   @id @default(uuid())
  name          String
  displayName   String?  @map("display_name")
  department    String
  role          UserRole
  password      String   // 加密后的密码密文 (iv:encryptedData)
  passwordSalt  String   @map("password_salt") // 用户独立的盐值（校验位）
  avatar        String?
  createdAt     DateTime @default(now()) @map("created_at")

  @@map("users")
}
```

**关键字段说明**:
- `password`: 存储格式为 `iv:encryptedData`
  - `iv`: 随机初始化向量 (16 bytes, hex 32 chars)
  - `encryptedData`: AES-256-CBC 加密后的密文
- `passwordSalt`: 每个用户独立的随机盐值 (16 bytes, hex 32 chars)
  - 作为校验位使用
  - 确保相同密码的不同用户加密结果完全不同

---

## 加密方案

### 算法选择

| 组件 | 算法 | 用途 |
|------|------|------|
| 对称加密 | **AES-256-CBC** | 密码加密 |
| 密钥派生 | **SHA-256** | 从 (密码+盐值) 派生加密密钥 |
| 盐值生成 | **crypto.randomBytes** | 生成用户独立的随机盐值 |

### 为什么使用独立盐值？

1. **防止彩虹表攻击**: 即使两个用户密码相同，加密结果也不同
2. **增加破解难度**: 攻击者需要为每个用户单独破解
3. **校验位功能**: 盐值作为校验位，验证数据完整性

---

## 加密流程

```
┌─────────────────────────────────────────────────────────────┐
│                        加密流程                              │
└─────────────────────────────────────────────────────────────┘

输入: 明文密码 + 用户独立盐值

1. 生成随机 IV (16 bytes)
   iv = randomBytes(16)
   
2. 派生加密密钥
   key = SHA256(明文密码 + 盐值)
   
3. AES-256-CBC 加密
   ciphertext = AES-256-CBC(明文密码, key, iv)
   
4. 组合存储
   password 字段 = iv:ciphertext
   passwordSalt 字段 = 盐值
```

### 代码实现

```typescript
/**
 * 加密密码
 * @param password 明文密码
 * @param salt 用户独立的盐值（校验位）
 * @returns 加密后的密文 (iv:encryptedData)
 */
export function encryptPassword(password: string, salt: string): string {
  // 1. 生成随机 IV
  const iv = crypto.randomBytes(16);

  // 2. 派生加密密钥：SHA256(密码 + 盐值)
  const key = crypto
    .createHash('sha256')
    .update(password + salt)
    .digest();

  // 3. AES-256-CBC 加密
  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
  let encrypted = cipher.update(password, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  // 4. 返回：IV + 密文
  return iv.toString('hex') + ':' + encrypted;
}
```

---

## 验证流程

```
┌─────────────────────────────────────────────────────────────┐
│                        验证流程                              │
└─────────────────────────────────────────────────────────────┘

输入: 用户输入密码 + 存储的密文 + 存储的盐值

1. 解析存储的密文
   [ivHex, encryptedData] = split(':')
   
2. 使用相同的密钥派生方式
   key = SHA256(输入密码 + 盐值)
   
3. AES-256-CBC 解密
   decrypted = AES-256-CBC-Decrypt(encryptedData, key, iv)
   
4. 时间安全比较
   return timingSafeEqual(decrypted, 输入密码)
```

### 代码实现

```typescript
/**
 * 验证密码
 * @param inputPassword 用户输入的密码
 * @param encryptedPassword 存储的加密密码 (iv:encryptedData)
 * @param salt 用户独立的盐值
 * @returns 是否验证通过
 */
export function verifyPassword(
  inputPassword: string,
  encryptedPassword: string,
  salt: string
): boolean {
  try {
    // 1. 解析存储的密码
    const [ivHex, encryptedData] = encryptedPassword.split(':');
    if (!ivHex || !encryptedData) return false;

    const iv = Buffer.from(ivHex, 'hex');

    // 2. 使用相同的密钥派生方式
    const key = crypto
      .createHash('sha256')
      .update(inputPassword + salt)
      .digest();

    // 3. AES-256-CBC 解密
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    // 4. 时间安全比较（防止时序攻击）
    return crypto.timingSafeEqual(
      Buffer.from(decrypted),
      Buffer.from(inputPassword)
    );
  } catch (error) {
    return false;
  }
}
```

---

## 安全特性

### 1. 独立盐值
- 每个用户拥有独立的 16 字节随机盐值
- 存储在 `password_salt` 字段
- 相同密码的不同用户，加密结果完全不同

### 2. 动态密钥派生
- 加密密钥 = SHA256(密码 + 盐值)
- 即使知道盐值，也无法直接解密
- 必须知道原始密码才能派生正确密钥

### 3. 随机 IV
- 每次加密使用不同的随机 IV
- 即使密码和盐值相同，多次加密结果也不同
- 防止模式分析攻击

### 4. 时间安全比较
- 使用 `crypto.timingSafeEqual` 比较密码
- 防止时序攻击（Timing Attack）
- 无论密码是否正确，比较时间恒定

---

## 使用示例

### 创建用户

```typescript
import { createUser } from '@/lib/db';

const user = await createUser({
  name: '张三',
  displayName: '张三（技术负责人）',
  department: '技术部',
  role: 'lead',
  password: 'Dev123!',
});

// 自动执行：
// 1. 生成随机盐值
// 2. 加密密码
// 3. 存储 password 和 passwordSalt
```

### 验证登录

```typescript
import { getUserWithPassword, verifyPassword } from '@/lib/db';

const user = await getUserWithPassword(userId);

// 传入用户独立的盐值进行验证
const isValid = verifyPassword(
  inputPassword,
  user.password,
  user.passwordSalt  // 用户独立的校验位
);

if (isValid) {
  // 登录成功
}
```

### 修改密码

```typescript
import { updateUser } from '@/lib/db';

await updateUser(userId, {
  password: 'NewPassword123!',
});

// 自动执行：
// 1. 生成新的随机盐值
// 2. 重新加密密码
// 3. 更新 password 和 passwordSalt
```

---

## 数据库示例

### 用户表数据示例

| id | name | password | password_salt |
|----|------|----------|---------------|
| user-1 | 张三 | `a1b2c3d4...e5f6:g7h8i9j0` | `k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6` |
| user-2 | 李四 | `b2c3d4e5...f6g7:h8i9j0k1` | `a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6` |

**说明**:
- 张三和李四的密码都是 `Dev123!`
- 但由于盐值不同，加密后的 `password` 字段完全不同
- 盐值作为校验位，确保数据完整性

---

## 性能指标

| 操作 | 平均耗时 | 说明 |
|------|----------|------|
| 生成盐值 | ~0.1ms | 随机字节生成 |
| 加密密码 | ~1ms | SHA256 + AES-256-CBC |
| 验证密码 | ~1ms | SHA256 + AES-256-CBC + 比较 |
| 存储增加 | ~64 bytes | 盐值 32 bytes + IV 32 bytes |

---

## 与其他方案对比

| 方案 | 盐值方式 | 安全性 | 适用场景 |
|------|----------|--------|----------|
| **本方案（独立盐值）** | 每个用户独立 | ⭐⭐⭐⭐⭐ | 推荐方案 |
| bcrypt | 内置盐值 | ⭐⭐⭐⭐⭐ | 传统方案，慢哈希 |
| Argon2 | 内置盐值 | ⭐⭐⭐⭐⭐ | 现代推荐方案 |
| 全局盐值 | 系统统一盐值 | ⭐⭐⭐ | 不推荐 |
| 无盐值 | 无 | ⭐ | ❌ 绝不使用 |

**选择理由**:
- 独立盐值防止彩虹表攻击
- 相比 bcrypt/Argon2 更快，适合高频验证
- 实现简单，可控性强

---

## 部署检查清单

- [ ] 数据库字段 `password_salt` 已添加
- [ ] 所有用户已分配独立盐值
- [ ] 密码已使用新方案加密
- [ ] 登录功能已更新支持盐值验证
- [ ] 密码修改功能已更新

---

## 更新记录

| 日期 | 版本 | 变更 |
|------|------|------|
| 2026-02-12 | v1.0 | 初始方案，使用全局密钥 |
| 2026-02-12 | v2.0 | 改为用户独立盐值（password_salt 字段） |

---

## 参考文档

- [盐值（Cryptographic Salt）](https://en.wikipedia.org/wiki/Salt_(cryptography))
- [AES-CBC 模式](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC))
- [SHA-256](https://en.wikipedia.org/wiki/SHA-2)
- [Node.js crypto 模块](https://nodejs.org/api/crypto.html)
